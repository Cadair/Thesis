%*****************************************************************************************
%*********************************** Third Chapter ***************************************
%*****************************************************************************************
\label{ch:Methodology}
\chapter{Methodology}  %Title of the Second Chapter

\begin{pycode}[chapter3]
ch3 = texfigure.Manager(pytex, number=3, base_path='./Chapter3/')
\end{pycode}

\graphicspath{\py|ch3.fig_path|}

%{\Large Knowledge at start:}
%\begin{itemize}
%	\item The coronal heating problem
%	\item MHD waves as a solution to the corona heating problem
%	\item photospheric dynamics
%	\item Magnetic wave guides.
%\end{itemize}
%
%{\Large Knowledge at end:}
%\begin{itemize}
%	\item The ideal MHD equations
%	\item Wave solutions for a uniform media
%	\item velocity perturbation calculations
%	\item Wave flux calcs
%	\item SAC, and numerical solutions to the ideal MHD equations
%	\item Static background conditions
%	\item Construction of flux surfaces
%	\item our domain setup, size, etc.
%\end{itemize}

%\section*{Outline}
%
%\begin{enumerate}
%
%	\item MHD
%	\begin{enumerate}
%		\item Ideal MHD
%		\item MHD Waves
%		
%	\end{enumerate}
%	\item Computational Methods
%	\begin{enumerate}
%		\item Numerical Solutions to Partial Differential Equations
%		\item Numerical MHD
%		\item The Sheffield Advanced Code (SAC)
%	\end{enumerate}
%	\item Magneto-static Background Conditions
%	
%\end{enumerate}
	
\section{Magnetohydrostatic Background Conditions}\label{sec:mhsbackground}

\section{Flux Surfaces}\label{sec:fluxsurfaces}

As shown in \cref{sec:Vpert}, MHD waves propagating through a plasma cause perturbations in the velocity of the plasma.
As the perturbation velocity is one of the physical variables calculated by the SAC code this fact provides a mechanism by which we can identify the waves in the simulation domain.
However, the challenge is decomposing the velocity vector calculated by SAC in the reference frame of the simulation domain ($Vx$, $Vy$, $Vz$) into the frame of the magnetic field ($V_\parallel$, $V_\perp$, $V_\phi$).
Considering this problem more closely, the $V_\parallel$ component is trivial to calculate, as it is the projection of $\vec{V}$ onto $\vec{B}$.
The $V_\phi$, the azimuthal component, is also simple, it can be defined as $V_\phi = V_\parallel \times V_\perp$.
Clearly therefore, the challenging component to calculate is the $V_\perp$ component, the component perpendicular to the magnetic field.
When only a two dimensional system is considered the perpendicular vector is well defined, it is perpendicular to the parallel vector in the one degree of freedom available to it.
In three dimensions however, there is a whole plane perpendicular to the parallel vector.
It is therefore obvious that some other construct is needed.

The solution to finding a perpendicular vector in three dimensions is to consider the concept of flux tubes.
A flux tube is a mathematical construct of a surface within a magnetic field that encloses a constant amount of magnetic flux over its whole length.
Flux tubes as a consequence of the fact they contain a fixed amount of magnetic flux trace the field and move with the magnetic field lines.
A flux tube constructed in the numerical domain would have a boundary, a `flux surface' which would allow the computation of a normal vector from this surface.
This flux surface would be constructed numerically in the domain, and therefore would be a series of small planes connected together to form the surface.
These planes are mathematically described by the equation of a plane.
The equation of a plane is minimally defined by: three arbitrary points in a Cartesian geometry, $x_{1,2,3}$, $y_{1,2,3}$, and $y_{1,2,3}$, where the numerical subscript denotes the index of the point; the normal vector $\vec{n}=(a,b,c)$ and a constant $d$.
\begin{equation}
	ax_{1,2,3}+by_{1,2,3}+cz_{1,2,3}+d=0.
\end{equation}
We can therefore use this to calculate a vector normal to our surface for each set of three points numerically defining the surface.

\subsection{Constructing Flux Surfaces Numerically}
\begin{pycode}[chapter3]
# This section is all about describing the construction of flux tubes, many imports are needed:
import sys
import os

import yt
import numpy as np
import matplotlib.pyplot as plt
from mayavi import mlab
from tvtk.api import tvtk

#pysac imports
import pysac.yt
import pysac.analysis.tube3D.tvtk_tube_functions as ttf
import pysac.plot.mayavi_plotting_functions as mpf
from pysac.plot.mayavi_seed_streamlines import SeedStreamline
from pysac.plot.divergingcolourmaps import get_mayavi_colourmap
from pysac.analysis.tube3D.process_utils import get_yt_mlab

### Load in and Config ###

ds = pysac.yt.SACGDFDataset((ch3.data_file('Slog_p240-0_A10_B005_00001.gdf')))
tube_r = 60

#if running this creates a persistant window just get it out of the way!
mlab.options.offscreen = True
fig = mlab.figure(bgcolor=(1, 1, 1))

cg = ds.index.grids[0]

#Slices
cube_slice = np.s_[:,:,:-5]
x_slice = np.s_[:,:,:,:-5]

#Define the size of the domain
xmax, ymax, zmax = np.array(cg['density_bg'].to_ndarray()[cube_slice].shape) - 1
domain = {'xmax':xmax, 'ymax':ymax, 'zmax':zmax}

bfield, vfield = get_yt_mlab(ds, cube_slice, flux=False)

#Create a scalar field of the magntiude of the vector field
bmag = mlab.pipeline.extract_vector_norm(bfield, name="Field line Normals")

vtk_width = r'0.59\columnwidth'
\end{pycode}

The construction one of these flux surfaces, and the set of normal vectors defined upon it, is described below.
This process makes use of the Visualisation Tool Kit (VTK\footnote{VTK 6.1 (\url{www.vtk.org})}) and the MayaVi package \cite{Ramachandran2011} to provide a high level Python interface to VTK.
The flux surface is constructed based on the definition of flux tubes and field lines, a flux tube will enclose a fixed number of field lines dependant upon the magnetic flux density.
Therefore the edge of the flux tube can be thought of as a set of field lines.
We can therefore calculate the surface of the flux tube by computing the field lines that form its outer boundary.
The process of computing these flux surfaces is illustrated in \cref{fig:circ_seeds,fig:fieldlines,fig:flux_surface,fig:zoomed_surface,fig:zoomed_glyphs} and described in the respective captions.

\begin{pycode}[chapter3]
xc = domain['xmax']/2
yc = domain['ymax']/2
ti = 0
n = 100

surf_seeds = []
for theta in np.linspace(0, 2 * np.pi, n, endpoint=False):
    surf_seeds.append([tube_r * np.cos(theta + 0.5 * ti) + xc,
                  tube_r * np.sin(theta + 0.5 * ti) + yc, domain['zmax']])
                  
seeds = np.array(surf_seeds)
#Add axes:
axes, outline = mpf.add_axes(np.array(zip(ds.domain_left_edge,ds.domain_right_edge)).flatten()/1e8)

#Add seed points to plot:
seed_points = mlab.points3d(seeds[:,0], seeds[:,1], seeds[:,2],
                            color=(0.231, 0.298, 0.752), scale_mode='none',
                            scale_factor=1.5)
circ_seeds = ch3.save_figure('circ_seeds', fig, fext='.png')
circ_seeds.figure_width = vtk_width
circ_seeds.caption=r"Due to the axisymmetric nature of the background conditions, an axisymmetric ring of seed points is chosen. This example uses a ring at a radius of $936$ km from the centre of the domain."

\end{pycode}
\py[chapter3]|circ_seeds|

\begin{pycode}[chapter3]
field_lines = SeedStreamline(seed_points = np.array(seeds))
bmag.add_child(field_lines)
field_lines.actor.mapper.scalar_visibility = False
field_lines.actor.property.color = (0,0,0)
field_lines.actor.property.line_width = 1.5

fieldlines = ch3.save_figure('fieldlines', fig, fext='.png')
fieldlines.figure_width = vtk_width
fieldlines.caption=r"The seed points are then used to trace field lines. The field lines naturally form a flux surface by definition."
\end{pycode}
\py[chapter3]|fieldlines|

\begin{pycode}[chapter3]
pd_seeds = ttf.make_circle_seeds(100, 60, **domain)
fieldlines, surface = ttf.create_flux_surface(bfield.outputs[0], pd_seeds)
surface.output.lines = None
flux_surface = mlab.pipeline.surface(surface.output)
flux_surface.actor.mapper.scalar_visibility = False
flux_surface.actor.property.color = (0.8,0.8,0.8)
#flux_surface.actor.property.line_width = 0

fig_flux_surface = ch3.save_figure('flux_surface', fig, fext='.png')
fig_flux_surface.figure_width = vtk_width
fig_flux_surface.caption=r"Once the field lines have been traced a surface is constructed from small polygons (triangles) using the vtkRuledSurfaceFilter algorithm."
\end{pycode}
\py[chapter3]|fig_flux_surface|

\begin{pycode}[chapter3]
axes.visible = False
outline.visible = False
flux_surface.actor.property.edge_visibility = True
zoomed_surface = ch3.save_figure('zoomed_surface', fig, fext='.png', azimuth = 90, elevation = 75, distance=80, focalpoint=[63, 120, 110], aa=20)
zoomed_surface.figure_width = vtk_width
zoomed_surface.caption=r"This figure shows the outlines of the triangles of which the surface comprises."
\end{pycode}
\py[chapter3]|zoomed_surface|


\begin{pycode}[chapter3]
poly_norms = ttf.make_poly_norms(surface.output)
normvec = mlab.pipeline.glyph(poly_norms.output)
normvec.glyph.glyph_source.glyph_source = normvec.glyph.glyph_source.glyph_dict['arrow_source']
normvec.glyph.glyph.scale_mode = 'data_scaling_off'
normvec.glyph.glyph.color_mode = 'color_by_scale'
normvec.glyph.glyph.scale_factor = 5
normvec.glyph.glyph_source.glyph_position = 'tail'

zoomed_glyphs = ch3.save_figure('zoomed_glyphs', fig, fext='.png', azimuth = 85, elevation = 80, distance=50, focalpoint=[63, 120, 110], aa=20)
zoomed_glyphs.figure_width = vtk_width
zoomed_glyphs.caption=r"By using the surface triangles a vector normal to the surface can be calculated at each vertex. This is done automatically by the vtkRuledSurfaceFilter algorithm."
\end{pycode}

\py[chapter3]|zoomed_glyphs|

Once the normal vectors have been constructed, it is simple to compute the azimuthal vector from the magnetic field unit vector and the normal vector $\vec{n_\phi}= \vec{n_\perp} \times \vec{n_\parallel}$ where $\vec{n_\perp},\ \vec{n_\parallel} $ are also both unit vectors. 
Using  $\vec{n_\perp},\ \vec{n_\parallel}$ and $\vec{n_\phi}$ it  is possible to project any vector quantity calculated in the simulations into this reference frame, and use it for the analysis of MHD waves.
